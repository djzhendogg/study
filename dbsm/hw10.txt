1 1
start transaction read only isolation level read committed;
-- Нужно гарантировать, что мы выдаем только актуальные места
-- Поэтому необходимо читать закоммиченные изменения, так как может произойти роллбек и некоторые места освободятся
-- Прочитать и отдать актуальные данные нам нужно один раз, поэтому нам не нужно гарантировать, что при втором прочтении данные останутся те же
-- Это связано с тем, что относительно других транзакций наша выполнится первее, чего нам достаточно
-- Значит мы не столкнемся ни с косой записью, ни с фантомным чтением, ни с повторным чтением

1 2
start transaction read write isolation level read committed;
-- Грязное чтение может помешать при выделении места, так как можем наткнуться, например, на чужое бронирования, которое роллбекнется
-- Не поддерживая повторяющее чтение мы ничего не теряем, так как относительно других транзакций мы выполнимся раньше, что будет означать, что в конкретный момент времени мы правы
-- При попытке забронировать одно и то же место в двух транзакциях первая, которая завершится, не даст добавить бронь второй транзакции (за счет constraint-а на ключ) - фантомная запись нам не грозит
-- Пишем только в одну табличку - косая запись не грозит

1 3
start transaction read write isolation level repeatable read;
-- При грязном чтении можем, например, успешно продлить бронь, которая роллбекнется
-- При неповторяющемся чтении мы можем начать транзакцию для одного пользователя, а затем владелец место изменится и мы обновим бронь уже для другого - необходимо поддержать повторяющееся чтение
-- Данные мы только обновляем, поэтому проблем с добавлением записей нет. При удалении записи мы ничем не рискуем, так как данных уже не будет - фантомная запись не грозит
-- Пишем только в одну табличку - косая запись не грозит

1 4
start transaction read write isolation level read committed;
-- Грязное чтение может помешать при покупке места, так как можем наткнуться, например, на чужое бронирования, которое роллбекнется
-- Не поддерживая повторяющее чтение мы ничего не теряем, так как относительно других транзакций мы выполнимся раньше, что будет означать, что в конкретный момент времени мы правы
-- При попытке купить одно и то же место в двух транзакциях первая, которая завершится, не даст добавить бронь второй транзакции (за счет constraint-а на ключ) - фантомная запись нам не грозит
-- Пишем только в одну табличку - косая запись не грозит

1 5
start transaction read write isolation level repeatable read;
-- При грязном чтении можем, например, успешно rкупить бронь, которая роллбекнется
-- При неповторяющемся чтении мы можем начать транзакцию для одного пользователя, а затем владелец место изменится и мы купим чужую бронь
-- Данные мы только обновляем, поэтому проблем с добавлением записей нет. При удалении записи мы ничем не рискуем, так как данных уже не будет - фантомная запись не грозит
-- Пишем только в одну табличку - косая запись не грозит

1 6
start transaction read only isolation level snapshot;
-- Выводим пользователю актуальную статистику - грязное чтение нам не хочется (допустим в одной транзакции скупили все билеты на самолет и теперь пользователю грустно, но транзакцию потом откатили)
-- Могут быть изменения в статистике, что кто-то купил забронированный билет -> портит статистику, поэтому поддерживаем повторное чтение
-- Кто-то может забронировать или купить свободный билет - портит статистику, поэтому хотим избавиться от фантомной записи
-- Только читаем - не грозит косая запись

1 7
start transaction read only isolation level snapshot;
-- Выводим пользователю актуальную статистику - грязное чтение нам не хочется (допустим в одной транзакции скупили все билеты на самолет и теперь пользователю грустно, но транзакцию потом откатили)
-- Могут быть изменения в статистике, что кто-то купил забронированный билет -> портит статистику, поэтому поддерживаем повторное чтение
-- Кто-то может забронировать или купить свободный билет - портит статистику, поэтому хотим избавиться от фантомной записи
-- Только читаем - не грозит косая запись

1 8
start transaction read only isolation level snapshot;
-- Невозможно скомпрессовать места правильно, пока у нас грязная запись - кто-то купил место, потом оно откатилось и теперь у нас дырка в распределении
-- Невозможно скомпрессовать места правильно, пока мы не поддерживаем повторное чтение - кто-то мог купить забронированное место, из-за чего он теперь должен быть ближе к началу
-- Невозможно скомпрессовать места правильно, пока у нас фантомная запись - кто-то купил/забронировал билет - либо его затрут, либо и вовсе вся сортировка сломается
-- Пишем только в одну табличку (не считая временной, которая зависит от основной, что никак не мешает) - косая запись не грозит

2 0
Запрашиваем у БД список свободных мест (FreeSeats) - ответ приходит в виде колонки из доступных мест, что мы и показываем. Если пользователь решает забронировать место, то делаем запрос Reserve, если покупает, то BuyFree или BuyReserved (если уже забронировано)
Все функции обернуты в транзакции с тем уровнем изоляции, который мы выбрали в прошлых заданиях

2 1
start transaction read only isolation level read committed;
select * from FreeSeats(1);
commit;

2 2
Результаты функций у нас уже человекочитаемые и не нуждаются в обработке, можем на прямую возвращать результаты
Все взаимодействие с пользователем так же достаточно хорошо описано в уже существующих функциях и поддерживают весь необходимый функционал для работы между пользователем и билетами

Поэтому для реализации достаточно обернуть в транзакции уже существующие функции

Список доступных мест, чтобы пользователь мог узнать, что он может сейчас купить/забронировать:
start transaction read only isolation level read committed;
select * from FreeSeats(...);
commit;

Забронировать интересующее место пользователя:
start transaction read write isolation level read committed;
select Reserve(...)
commit;

Продлить бронь пользователя:
start transaction read write isolation level repeatable read;
select ExtendReservation(...)
commit;

Купить забронированное пользователем место:
start transaction read write isolation level repeatable read;
select BuyReserved(...)
commit;

Просто закупить свободное место:
start transaction read write isolation level read committed;
select BuyFree(...)
commit;

2 3
-- Рассмотрим сценарий бронирования и покупки места

start transaction read write isolation level read committed;
select Reserve(1, 'password1', 1, '001A')
commit;

start transaction read write isolation level repeatable read;
select ExtendReservation(1, 'password1', 1, '001A')
commit;

start transaction read write isolation level repeatable read;
select BuyReserved(1, 'password1', 1, '001A')
commit;